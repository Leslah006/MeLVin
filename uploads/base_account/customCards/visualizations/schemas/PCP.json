{"title":"PCP","description":"A parallel coordinates plot displays several data dimensions as a set of vertical axes where each data item is represented as a line that passes through each axe at the corresponding value.","className":"PCP","allowOutConn":true,"allowInConn":true,"outConnections":[{"type":"OPTION_CONNECTION","name":"Option","desc":"List of options","disabled":true,"index":0},{"type":"SELECTION_CONNECTION","unique":true,"name":"Range selections","index":0}],"inConnections":[{"type":"OPTION_CONNECTION","unique":true,"name":"Option","desc":"List of options","disabled":true,"index":0},{"type":"DATA_CONNECTION","unique":true,"name":"Tabular data","desc":"Data","index":0},{"type":"SELECTION_CONNECTION","unique":true,"name":"Range selections","index":0},{"type":"COLOR_CONNECTION","unique":true,"name":"Data groups","index":0}],"shareSelection":false,"shareData":true,"category":"viz","selectedLibs":["plotly-latest.min.js"],"previewDataFile":"","selectedPreview":"pcp.svg","methods":{"init":{"code":" this.options = {\n            scrollZoom: true,\n            showLink: false,\n            modeBarButtonsToRemove: ['sendDataToCloud'],\n            displaylogo: false,\n            displayModeBar: true\n};\n\nconsole.log(\"PCP\");\nlet self = this;\nPlotly.purge(container);\n$(container).html(\"\");\n\n\nlet attributes = input.data.schema.attributes;\n\nlet columns = [];\nstate.options[0].value.forEach(function (value) {\n    columns.push(value)\n});\n\nlet columnsIndex = columns.map(function (columnName) {\n    return Object.keys(attributes).indexOf(columnName);\n});\n\nlet incorrectCols = columnsIndex.some(function (value) {\n    return value === -1;\n});\nlet correctInput = input.data.data.length > 0 && columns.length > 1 && !incorrectCols;\nvar coloredData = 0;\n\nif (correctInput) {\n    let finalData = [];\n    let colorUnique = [];\n    let colorRaw = [];\n    let selections = [].concat.apply([], input.selection);\n\n    input.data.data.forEach(function (data) {\n        columns.forEach(function (column, i) {\n            if (typeof finalData[i] === \"undefined\") finalData[i] = [];\n            finalData[i].push(data[columnsIndex[i]]);\n        });\n\n        var traceNum = 0;\n        if (input.groups)\n            for (var i = 0; i < input.groups.length; i++) {\n                if (input.groups[i].points && input.groups[i].points[data[0]]) {\n                    traceNum = i + 1;\n                }\n            }\n        if (traceNum > 0) coloredData++;\n        colorRaw.push(traceNum);\n    });\n\n    let selectedPoints = {};\n    selections.filter(function (selection) {\n        return selection.type === 'points'\n    }).forEach(function (selection) {\n        Object.assign(selectedPoints, selection.points)\n    });\n\n    selectedPoints = Object.keys(selectedPoints);\n\n    let colorMap = ['#000000'].concat((input.groups || []).map(function (group) {\n        return group.color\n    }));\n\n    if (coloredData === input.data.data.length) colorMap.shift();\n    let trace = {};\n    if (selectedPoints.length > 1) {\n\n        trace = {\n            type: 'parcoords',\n            line: {\n                color: input.data.data.map(function (item) {\n                    return selectedPoints.indexOf(item[0]) !== -1 ? 1 : 0;\n                }),\n                colorscale: [[0, 'black'], [1, 'red']]\n            },\n            dimensions: []\n        };\n    } else if (colorMap.length > 1) {\n        let scale = colorMap.map(function (color, i) {\n            return [i / (colorMap.length - 1), color];\n        });\n\n        trace = {\n            type: 'parcoords',\n            line: {\n                color: colorRaw,\n                colorscale: scale\n            },\n            dimensions: []\n        };\n    } else {\n        trace = {\n            type: 'parcoords',\n            line: {\n                color: colorMap[0]\n            },\n            dimensions: []\n        };\n    }\n\n    columns.forEach(function (column, i) {\n        if (attributes[column].attribute_type === \"QUANTITATIVE\") {\n\n            var properties = {\n                range: [_.min(finalData[i]), _.max(finalData[i])],\n                label: column,\n                values: finalData[i]\n            };\n\n            if (selections.length > 0) {\n\n                let selectionColumn = selections.map(function (selection) {\n                    return selection.name;\n                }).indexOf(column);\n\n                if (selectionColumn > -1) {\n                    let range = selections[selectionColumn].range;\n                    properties[\"constraintrange\"] = [range[0], range[1]];\n                }\n            }\n\n            trace.dimensions.push(properties);\n        } else {\n            var unique = finalData[i].filter(function (value, index, self) {\n                return self.indexOf(value) === index;\n            });\n            var mappedData = finalData[i].map(function (data) {\n                return unique.indexOf(data);\n            });\n            trace.dimensions.push({\n                tickvals: Array.apply(null, {\n                    length: unique.length\n                }).map(Function.call, Number),\n                ticktext: unique,\n                label: column,\n                values: mappedData\n            })\n        }\n    });\n\n    Plotly.react(container, [trace], {\n        margin: {\n            l: 50,\n            r: 50,\n            b: 30,\n            t: 70,\n            pad: 5\n        },\n        autosize: true,\n        dragmode: \"pan\"\n    }, this.options);\n    $(container)[0].on('plotly_restyle', function () {\n        self._onSelection(trace, input, setProperty)\n    });\n\n} else {\n    var message = \"\";\n    if (input.data.data.length === 0)\n        message = 'No data provieded';\n    else if (columns.length <= 1)\n        message = 'Not enough attributes provided for the visualization';\n    else\n        message = 'Specified dimensions not found in the provided data';\n\n    $(container).html('<div style=\"height:100%;display:flex;flex-flow: column;justify-content:center;align-items:center;\">' +\n        '<div class=\"alert alert-info\" role=\"alert\">' + message +\n        '</div>' +\n        '</div>');\n}","args":"container, input, state, dataHandler, setProperty","isRemovable":false,"hasCustomArgs":false,"canBeRenamed":false},"update":{"code":"this.init(container, input, state, dataHandler, setProperty);","args":"container, input, state, dataHandler, setProperty","isRemovable":false,"hasCustomArgs":false,"canBeRenamed":false},"_onSelection":{"code":"var filter = [];\nconsole.log(\"PCP Selection:\" + trace);\ntrace.dimensions.forEach(function (dimension) {\n    if (typeof dimension.constraintrange !== \"undefined\") {\n        if (typeof dimension.range !== \"undefined\" && (dimension.constraintrange[0] !== dimension.range[0] || dimension.constraintrange[1] !== dimension.range[1]))\n            filter.push({\n                filterType: \"QUANTITATIVE\",\n                selectedRange: dimension.constraintrange,\n                name: dimension.label\n            });\n        else if (typeof dimension.ticktext !== \"undefined\") {\n            var items = dimension.ticktext.slice(Math.ceil(dimension.constraintrange[0]), Math.floor(dimension.constraintrange[1]) + 1);\n            filter.push({\n                filterType: \"CATEGORICAL\",\n                selectedItems: items,\n                name: dimension.label\n            })\n        }\n    }\n});\n\nvar selectionPoints = {\n    type: \"points\",\n    points: {}\n};\nvar attrs = Object.keys(input.data.schema.attributes);\ninput.data.data.forEach(function (data) {\n    var isInGroup = true;\n    for (var i = 0; i < filter.length && isInGroup; i++) {\n        var selection = filter[i];\n        if (selection.filterType === \"QUANTITATIVE\") {\n            isInGroup = selection.selectedRange[0] <= data[attrs.indexOf(selection.name)] &&\n                selection.selectedRange[1] >= data[attrs.indexOf(selection.name)];\n        } else {\n            isInGroup = selection.selectedItems.indexOf(data[attrs.indexOf(selection.name)]) !== -1;\n        }\n    }\n\n    if (isInGroup) selectionPoints.points[data[0]] = true;\n});\n\nif (Object.keys(selectionPoints.points).length === input.data.data.length)\n    selectionPoints.points = {};\nsetProperty(\"selection\", selectionPoints);","args":"trace, input, setProperty","isRemovable":true,"hasCustomArgs":true,"canBeRenamed":true}},"options":[{"type":"INPUT_LIST","help":"Data column names to be used as vertical axes in the PCP plot","label":"Column names"}],"thumbnail":"./auth/previews/pcp.svg","preview":"pcp.svg","id":"PCP","loadPreview":true,"hasOptions":true}